# 🔧 Rebuilding Python: Manual Re-Implementations of Built-In Functions

Welcome to my personal learning project! This repository contains Python implementations of commonly used built-in functions and operations — rewritten from scratch.

The goal: **understand what's really going on under the hood** in terms of **logic, time complexity, and trade-offs** by re-implementing these functions manually, without using shortcuts like `sorted()`, `abs()`, or `set()`.

---

## 🎯 Purpose

Built-in Python functions are efficient, but they often hide the cost and complexity of the operations they perform. By re-creating them manually, I aim to:

- Develop a deeper intuition for **time and space complexity**
- Practice **algorithmic thinking and data structure design**
- Understand **why** certain algorithms are chosen in real-world interpreters like CPython
- Sharpen problem-solving skills through **UMPIRE-style breakdowns**

---

## 📁 Project Structure

Each file includes:
- Problem description
- Constraints
- Sample test cases
- UMPIRE framework breakdown
- Manual implementation
- Time & space complexity analysis

## 🚀 Getting Started
To run any challenge:
```
Manual-Re-Implementation-of-Built-In-Functions-Time-Complexity-Challenge-/<challenge folder>/main.py
```

🧪 Learning Goals
- Improve algorithm fluency
- Analyze runtime before using Python built-ins
- Prepare for coding interviews with deeper knowledge
- Think critically about trade-offs in implementation

📜 License
This project is licensed under the MIT License. Feel free to fork, contribute, or use this for educational purposes!

🙋‍♀️ Author
Created with ❤️ by Divya Ganesh
Questions, ideas, or want to collaborate? Open an issue or PR!